# Чтение входных данных
n, m = map(int, input().split())  # Размеры таблицы (n - строки, m - столбцы)
grid = [list(map(int, input().split())) for _ in range(n)]  # Кислоты на клетках

# Динамическое программирование
dp = [[0] * m for _ in range(n)]  # Массив для хранения минимального урона
dp[0][0] = grid[0][0]  # Начальная клетка, урон равен её значению

# Заполняем первую строку
for j in range(1, m):
    dp[0][j] = dp[0][j-1] + grid[0][j]

# Заполняем первый столбец
for i in range(1, n):
    dp[i][0] = dp[i-1][0] + grid[i][0]

# Заполняем остальную часть таблицы
for i in range(1, n):
    for j in range(1, m):
        dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]

# Восстановление пути
path = []
i, j = n - 1, m - 1
while i > 0 or j > 0:
    path.append((i+1, j+1))  # Добавляем текущую клетку в путь (включаем 1 индексацию)
    if i == 0:  # Если мы на первой строке, можем двигаться только вправо
        j -= 1
    elif j == 0:  # Если мы на первом столбце, можем двигаться только вниз
        i -= 1
    else:
        if dp[i-1][j] < dp[i][j-1]:  # Выбираем, где был минимальный урон
            i -= 1
        else:
            j -= 1

path.append((1, 1))  # Добавляем начальную клетку
path.reverse()  # Разворачиваем путь, чтобы он был от начала до конца

# Вывод результата
print(dp[n-1][m-1])  # Минимальный урон
for p in path:  # Печатаем путь
    print(p[0], p[1])
