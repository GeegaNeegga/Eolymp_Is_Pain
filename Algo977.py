n = int(input())  # Считываем количество вершин

# Формируем матрицу смежности, начиная с индекса 1
g = [[0] * (n + 1)]
for _ in range(n):
    g.append([0] + list(map(int, input().split())))

used = [0] * (n + 1)  # Массив для отметки посещённых вершин
c = 0                # Счётчик посещённых вершин
Edges = 0            # Счётчик рёбер

# Обход графа в глубину
def dfs(v):
    global c
    used[v] = 1
    c += 1
    for i in range(1, n + 1):
        if g[v][i] and not used[i]:  # Если существует ребро и вершина не посещена
            dfs(i)

# Подсчёт количества рёбер
for i in range(1, n + 1):
    Edges += sum(g[i])
Edges //= 2  # Каждое ребро учитывается дважды

dfs(1)  # Запуск DFS с вершины 1

# Условие для дерева: граф связный (c == n) и количество рёбер = n - 1
if Edges == n - 1 and c == n:
    print("YES")
else:
    print("NO")

